{
  "ver": "1.0.25",
  "uuid": "b4a0463a-7688-4b0e-9084-cef75060ae18",
  "compiledShaders": [
    {
      "glsl1": {
        "vert": "\nprecision highp float;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matWorld;\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\n#if USE_TEXTURE\nattribute vec2 a_uv0;\nvarying vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  gl_Position = pos;\n}",
        "frag": "\nprecision highp float;\n#if USE_ALPHA_TEST\n#endif\nvarying vec4 v_color;\n#if USE_TEXTURE\nvarying vec2 v_uv0;\nuniform sampler2D texture;\n#endif\nuniform vec4 i_shadowColor;\nuniform vec4 i_outlineColor;\nuniform vec4 i_olShadowColor;\nuniform vec4 i_color1;\nuniform vec4 i_color2;\nuniform vec4 i_color3;\nuniform vec4 i_flColor;\nuniform vec4 i_glowColor;\nuniform vec2 i_shadowOffset;\nuniform vec2 i_outlineWidth;\nuniform vec2 i_olShadowOffset;\nuniform vec2 i_glowWidth;\nuniform float i_shadow;\nuniform float i_outline;\nuniform float i_olShadow;\nuniform float i_gradient;\nuniform float i_flowLight;\nuniform float i_flTime;\nuniform float i_flRot;\nuniform float i_flWidth;\nuniform float i_glow;\nuniform float i_glowDepth;\nconst float PI = 3.1415;\nconst float accuracy = 32.;\nfloat getA(vec2 p) {\n  vec2 tp = vec2(p.x+.5, .5-p.y);\n  float a = 0.0001;\n  a += step(abs(p.x), .5)*step(abs(p.y), .5)*texture2D(texture, tp).a;\n  return a;\n}\nvec4 transCol(vec4 c1, vec4 c2) {\n  float k = (1.-c1.a)*c2.a/(c1.a+c2.a);\n  vec4 c = vec4(.0);\n  c.rgb = mix(c1.rgb, c2.rgb, k);\n  c.a = c1.a+k*c2.a;\n  return c;\n}\nvoid main () {\n  float dw = .0;\n  dw += step(.5, i_shadow)*abs(i_shadowOffset.x);\n  dw += step(.5, i_outline)*abs(i_outlineWidth.x*2.);\n  dw += step(.5, i_outline)*step(.5, i_olShadow)*abs(i_olShadowOffset.x);\n  dw += step(.5, i_glow)*abs(i_glowWidth.x*2.);\n  float scale = 1.+dw;\n  vec2 uv = vec2(v_uv0.x-.5, .5-v_uv0.y)*scale;\n  uv -= step(.5, i_shadow)*i_shadowOffset*0.5;\n  vec2 olsuv = vec2(i_olShadowOffset.x+sign(i_olShadowOffset.x)*i_outlineWidth.x, i_olShadowOffset.y+sign(i_olShadowOffset.y)*i_outlineWidth.y);\n  uv -= step(.5, i_outline)*step(.5, i_olShadow)*olsuv*0.5;\n  vec4 col = vec4(.0);\n  float a = getA(uv);\n  col += step(1.5, i_gradient)*step(.0, uv.y)*mix(i_color1, i_color2, 1.-uv.y*2./scale);\n  col += step(1.5, i_gradient)*step(uv.y, .0)*mix(i_color2, i_color3, -uv.y*2./scale);\n  col += step(.5, i_gradient)*step(i_gradient, 1.5)*mix(i_color1, i_color2, .5-uv.y/scale);\n  col += step(i_gradient, .5)*i_color1;\n  col.rgb *= step(.0, a);\n  col.a *= a;\n  if(i_flowLight > .5) {\n    float rad = PI*i_flRot/180.;\n    float w = i_flWidth/cos(rad);\n    float tan_rad = tan(rad);\n    float t = fract(i_flTime)*(1.+w+abs(tan_rad))-w-step(.0, tan_rad)*abs(tan_rad);\n    float x = v_uv0.x-(1.-v_uv0.y)*tan_rad;\n    col.rgb = mix(col.rgb, i_flColor.rgb, step(t, x)*step(x, t+w)*(1.-smoothstep(.0, w*.5, abs(x-t-w*.5)))*i_flColor.a);\n  }\n  if(i_shadow > .5) {\n    vec4 sc = step(.5, i_shadow)*vec4(i_shadowColor.rgb, i_shadowColor.a*getA(vec2(uv)+i_shadowOffset));\n    col = transCol(col, sc);\n  }\n  if(i_outline > .5) {\n    float ola = .0;\n    float ola_shadow = .0;\n    float rot = PI*0.5;\n    vec2 tuv = uv+step(.5, i_shadow)*i_shadowOffset;\n    for(float i=.0;i<accuracy;i++) {\n      float rad = PI*2./accuracy*i;\n      vec2 uv_d;\n      uv_d.x = cos(rot)*cos(rad)*i_outlineWidth.y-sin(rot)*sin(rad)*i_outlineWidth.x;\n      uv_d.y = sin(rot)*cos(rad)*i_outlineWidth.y+cos(rot)*sin(rad)*i_outlineWidth.x;\n      ola = max(ola, getA(tuv+uv_d));\n      ola_shadow = step(.5, i_olShadow)*max(ola_shadow, getA(tuv+i_olShadowOffset+uv_d));\n    }\n    vec4 olc = vec4(i_outlineColor.rgb, i_outlineColor.a*ola);\n    col = transCol(col, olc);\n    vec4 olc_shadow = step(.5, i_olShadow)*vec4(i_olShadowColor.rgb, i_olShadowColor.a*ola_shadow);\n    col = transCol(col, olc_shadow);\n  }\n  if(i_glow > .5) {\n    float ga = .0;\n    float rot = PI*0.5;\n    float tx = i_glowWidth.x + step(.5, i_outline)*i_outlineWidth.x;\n    float ty = i_glowWidth.y + step(.5, i_outline)*i_outlineWidth.y;\n    if(i_glow > 2.5) {\n      for(float i=.0;i<accuracy;i++) {\n        float rad = PI*2./accuracy*i;\n        for(float j=.0;j<32.;j++) {\n          vec2 uv_d;\n          uv_d.x = cos(rot)*cos(rad)*ty+-sin(rot)*sin(rad)*tx;\n          uv_d.y = sin(rot)*cos(rad)*ty+cos(rot)*sin(rad)*tx;\n          uv_d *= j/32.;\n          ga += getA(uv+uv_d);\n        }\n      }\n      ga /= accuracy*32.;\n    }\n    else if(i_glow > 1.5) {\n      for(float i=.0;i<accuracy;i++) {\n        float rad = PI*2./accuracy*i;\n        for(float j=.0;j<16.;j++) {\n          vec2 uv_d;\n          uv_d.x = cos(rot)*cos(rad)*ty-sin(rot)*sin(rad)*tx;\n          uv_d.y = sin(rot)*cos(rad)*ty+cos(rot)*sin(rad)*tx;\n          uv_d *= j/16.;\n          ga += getA(uv+uv_d);\n        }\n      }\n      ga /= accuracy*16.;\n    }\n    else {\n      for(float i=.0;i<accuracy;i++) {\n        float rad = PI*2./accuracy*i;\n        for(float j=.0;j<8.;j++) {\n          vec2 uv_d;\n          uv_d.x = cos(rot)*cos(rad)*ty-sin(rot)*sin(rad)*tx;\n          uv_d.y = sin(rot)*cos(rad)*ty+cos(rot)*sin(rad)*tx;\n          uv_d *= j/8.;\n          ga += getA(uv+uv_d);\n        }\n      }\n      ga /= accuracy*8.;\n    }\n    ga = smoothstep(.0, 1., ga*i_glowDepth);\n    vec4 gc = vec4(i_glowColor.rgb, i_glowColor.a*ga);\n    col = transCol(col, gc);\n  }\n  col.a *= v_color.a;\n  gl_FragColor = col;\n}"
      },
      "glsl3": {
        "vert": "\nprecision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nin vec3 a_position;\nin vec4 a_color;\nout vec4 v_color;\n#if USE_TEXTURE\nin vec2 a_uv0;\nout vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  gl_Position = pos;\n}",
        "frag": "\nprecision highp float;\n#if USE_ALPHA_TEST\n  uniform ALPHA_TEST {\n    float alphaThreshold;\n  };\n#endif\nin vec4 v_color;\n#if USE_TEXTURE\nin vec2 v_uv0;\nuniform sampler2D texture;\n#endif\nuniform UARGS {\n  vec4 i_shadowColor;\n  vec4 i_outlineColor;\n  vec4 i_olShadowColor;\n  vec4 i_color1;\n  vec4 i_color2;\n  vec4 i_color3;\n  vec4 i_flColor;\n  vec4 i_glowColor;\n  vec2 i_resolution;\n  vec2 i_shadowOffset;\n  vec2 i_outlineWidth;\n  vec2 i_olShadowOffset;\n  vec2 i_glowWidth;\n  float i_shadow;\n  float i_outline;\n  float i_olShadow;\n  float i_gradient;\n  float i_flowLight;\n  float i_flTime;\n  float i_flRot;\n  float i_flWidth;\n  float i_glow;\n  float i_glowDepth;\n};\nconst float PI = 3.1415;\nconst float accuracy = 32.;\nfloat getA(vec2 p) {\n  vec2 tp = vec2(p.x+.5, .5-p.y);\n  float a = 0.0001;\n  a += step(abs(p.x), .5)*step(abs(p.y), .5)*texture2D(texture, tp).a;\n  return a;\n}\nvec4 transCol(vec4 c1, vec4 c2) {\n  float k = (1.-c1.a)*c2.a/(c1.a+c2.a);\n  vec4 c = vec4(.0);\n  c.rgb = mix(c1.rgb, c2.rgb, k);\n  c.a = c1.a+k*c2.a;\n  return c;\n}\nvoid main () {\n  float dw = .0;\n  dw += step(.5, i_shadow)*abs(i_shadowOffset.x);\n  dw += step(.5, i_outline)*abs(i_outlineWidth.x*2.);\n  dw += step(.5, i_outline)*step(.5, i_olShadow)*abs(i_olShadowOffset.x);\n  dw += step(.5, i_glow)*abs(i_glowWidth.x*2.);\n  float scale = 1.+dw;\n  vec2 uv = vec2(v_uv0.x-.5, .5-v_uv0.y)*scale;\n  uv -= step(.5, i_shadow)*i_shadowOffset*0.5;\n  vec2 olsuv = vec2(i_olShadowOffset.x+sign(i_olShadowOffset.x)*i_outlineWidth.x, i_olShadowOffset.y+sign(i_olShadowOffset.y)*i_outlineWidth.y);\n  uv -= step(.5, i_outline)*step(.5, i_olShadow)*olsuv*0.5;\n  vec4 col = vec4(.0);\n  float a = getA(uv);\n  col += step(1.5, i_gradient)*step(.0, uv.y)*mix(i_color1, i_color2, 1.-uv.y*2./scale);\n  col += step(1.5, i_gradient)*step(uv.y, .0)*mix(i_color2, i_color3, -uv.y*2./scale);\n  col += step(.5, i_gradient)*step(i_gradient, 1.5)*mix(i_color1, i_color2, .5-uv.y/scale);\n  col += step(i_gradient, .5)*i_color1;\n  col.rgb *= step(.0, a);\n  col.a *= a;\n  if(i_flowLight > .5) {\n    float rad = PI*i_flRot/180.;\n    float w = i_flWidth/cos(rad);\n    float tan_rad = tan(rad);\n    float t = fract(i_flTime)*(1.+w+abs(tan_rad))-w-step(.0, tan_rad)*abs(tan_rad);\n    float x = v_uv0.x-(1.-v_uv0.y)*tan_rad;\n    col.rgb = mix(col.rgb, i_flColor.rgb, step(t, x)*step(x, t+w)*(1.-smoothstep(.0, w*.5, abs(x-t-w*.5)))*i_flColor.a);\n  }\n  if(i_shadow > .5) {\n    vec4 sc = step(.5, i_shadow)*vec4(i_shadowColor.rgb, i_shadowColor.a*getA(vec2(uv)+i_shadowOffset));\n    col = transCol(col, sc);\n  }\n  if(i_outline > .5) {\n    float ola = .0;\n    float ola_shadow = .0;\n    float rot = PI*0.5;\n    vec2 tuv = uv+step(.5, i_shadow)*i_shadowOffset;\n    for(float i=.0;i<accuracy;i++) {\n      float rad = PI*2./accuracy*i;\n      vec2 uv_d;\n      uv_d.x = cos(rot)*cos(rad)*i_outlineWidth.y-sin(rot)*sin(rad)*i_outlineWidth.x;\n      uv_d.y = sin(rot)*cos(rad)*i_outlineWidth.y+cos(rot)*sin(rad)*i_outlineWidth.x;\n      ola = max(ola, getA(tuv+uv_d));\n      ola_shadow = step(.5, i_olShadow)*max(ola_shadow, getA(tuv+i_olShadowOffset+uv_d));\n    }\n    vec4 olc = vec4(i_outlineColor.rgb, i_outlineColor.a*ola);\n    col = transCol(col, olc);\n    vec4 olc_shadow = step(.5, i_olShadow)*vec4(i_olShadowColor.rgb, i_olShadowColor.a*ola_shadow);\n    col = transCol(col, olc_shadow);\n  }\n  if(i_glow > .5) {\n    float ga = .0;\n    float rot = PI*0.5;\n    float tx = i_glowWidth.x + step(.5, i_outline)*i_outlineWidth.x;\n    float ty = i_glowWidth.y + step(.5, i_outline)*i_outlineWidth.y;\n    if(i_glow > 2.5) {\n      for(float i=.0;i<accuracy;i++) {\n        float rad = PI*2./accuracy*i;\n        for(float j=.0;j<32.;j++) {\n          vec2 uv_d;\n          uv_d.x = cos(rot)*cos(rad)*ty+-sin(rot)*sin(rad)*tx;\n          uv_d.y = sin(rot)*cos(rad)*ty+cos(rot)*sin(rad)*tx;\n          uv_d *= j/32.;\n          ga += getA(uv+uv_d);\n        }\n      }\n      ga /= accuracy*32.;\n    }\n    else if(i_glow > 1.5) {\n      for(float i=.0;i<accuracy;i++) {\n        float rad = PI*2./accuracy*i;\n        for(float j=.0;j<16.;j++) {\n          vec2 uv_d;\n          uv_d.x = cos(rot)*cos(rad)*ty-sin(rot)*sin(rad)*tx;\n          uv_d.y = sin(rot)*cos(rad)*ty+cos(rot)*sin(rad)*tx;\n          uv_d *= j/16.;\n          ga += getA(uv+uv_d);\n        }\n      }\n      ga /= accuracy*16.;\n    }\n    else {\n      for(float i=.0;i<accuracy;i++) {\n        float rad = PI*2./accuracy*i;\n        for(float j=.0;j<8.;j++) {\n          vec2 uv_d;\n          uv_d.x = cos(rot)*cos(rad)*ty-sin(rot)*sin(rad)*tx;\n          uv_d.y = sin(rot)*cos(rad)*ty+cos(rot)*sin(rad)*tx;\n          uv_d *= j/8.;\n          ga += getA(uv+uv_d);\n        }\n      }\n      ga /= accuracy*8.;\n    }\n    ga = smoothstep(.0, 1., ga*i_glowDepth);\n    vec4 gc = vec4(i_glowColor.rgb, i_glowColor.a*ga);\n    col = transCol(col, gc);\n  }\n  col.a *= v_color.a;\n  gl_FragColor = col;\n}"
      }
    }
  ],
  "subMetas": {}
}